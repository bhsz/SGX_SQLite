#include "Enclave_t.h" // Headers for trusted part (autogenerated by edger8r)
#include "sqlite3.h"
#include <string>
#include "MessageExchange.h"
#include "Utility.h"

sqlite3* db; // Database connection object

// SQLite callback function for printing results
static int callback(void *NotUsed, int argc, char **argv, char **azColName){
    int i;
    for(i = 0; i < argc; i++){
        std::string azColName_str = azColName[i];
        std::string argv_str = (argv[i] ? argv[i] : "NULL");
        ocall_print_string((azColName_str + " = " + argv_str + "\n").c_str());
    }
    ocall_print_string("\n");
    return 0;
}

void ecall_opendb(const char *dbname){
    int rc; // For return status of SQLite
    rc = sqlite3_open(dbname, &db); // Opening database
    if (rc) {
        ocall_println_string("SQLite error - can't open database connection: ");
        ocall_println_string(sqlite3_errmsg(db));
        return;
    }
    ocall_print_string("Enclave: Created database connection to ");
    ocall_println_string(dbname);
}

void ecall_execute_sql(const char *sql){
    int rc;
    char *zErrMsg = 0;
    rc = sqlite3_exec(db, sql, callback, 0, &zErrMsg);
    if (rc) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return;
    }
}

std::string read_customer(void) {
    const char *sql = "SELECT * FROM Customer;";

    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, nullptr);
    if (rc != SQLITE_OK) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return "";
    }
    
    std::string res;
    bool is_first = true;
    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        if (is_first) {
            is_first = false;
        } else {
            res += ",";
        }

        res += "(";
        // custkey
        res += std::to_string(sqlite3_column_int(stmt, 0));
        res += ",";
        // nationkey
        res += std::to_string(sqlite3_column_int64(stmt, 1));
        res += ",";
        // acctbal
        res += std::to_string(sqlite3_column_double(stmt, 2));
        res += ",";
        // name
        res += '\'';
        const char *name_ptr = (const char *)sqlite3_column_text(stmt, 3);
        std::string name(name_ptr, strlen(name_ptr));
        res += name;
        res += '\'';
        res += ",";
        // mktsegment
        res += '\'';
        const char *mktsegment_ptr = (const char *)sqlite3_column_text(stmt, 4);
        std::string mktsegment(mktsegment_ptr, strlen(mktsegment_ptr));
        res += mktsegment;
        res += '\'';
        res += ")";
    }

    sqlite3_finalize(stmt);
    return (res != "") ? ("INSERT INTO Customer VALUES " + std::move(res) + ";") : ""; 
}

void ecall_read_customer(char *buf, size_t length){
    (void)(length);
    auto res = read_customer();
    if ((res.size() + 1) > length) {
        ocall_println_string("ECALL READ CUSTOMER - RESULT BIGGER THAN BUFFER");
        return;
    }
    memcpy(buf, res.c_str(), res.size() + 1);
}

std::string read_orders(void) {
    const char *sql = "SELECT * FROM Orders;";

    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, nullptr);
    if (rc != SQLITE_OK) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return "";
    }

    std::string res;
    bool is_first = true;
    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        if (is_first) {
            is_first = false;
        } else {
            res += ",";
        }

        res += "(";
        // orderkey
        res += std::to_string(sqlite3_column_int(stmt, 0));
        res += ",";
        // custkey
        res += std::to_string(sqlite3_column_int64(stmt, 1));
        res += ",";
        // totalprice
        res += std::to_string(sqlite3_column_double(stmt, 2));
        res += ",";
        // orderdate
        res += '\'';
        const char *date_ptr = (const char *)sqlite3_column_text(stmt, 3);
        std::string date(date_ptr, strlen(date_ptr));
        res += date;
        res += '\'';
        res += ",";
        // shippingpriority
        res += std::to_string(sqlite3_column_int(stmt, 4));
        res += ")";
    }

    sqlite3_finalize(stmt);
    return (res != "") ? ("INSERT INTO Orders VALUES " + std::move(res) + ";") : ""; 
}

void ecall_read_orders(char *buf, size_t length) {
    (void)(length);
    auto res = read_orders();
    if ((res.size() + 1) > length) {
        ocall_println_string("ECALL READ ORDERS - RESULT BIGGER THAN BUFFER");
        return;
    }
    memcpy(buf, res.c_str(), res.size() + 1);
}

std::string read_lineitem(void) {
    const char *sql = "SELECT * FROM Lineitem;";

    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, nullptr);
    if (rc != SQLITE_OK) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return "";
    }

    std::string res;
    bool is_first = true;
    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        if (is_first) {
            is_first = false;
        } else {
            res += ",";
        }

        res += "(";
        // orderkey
        res += std::to_string(sqlite3_column_int64(stmt, 0));
        res += ",";
        // partkey
        res += std::to_string(sqlite3_column_int64(stmt, 1));
        res += ",";
        // suppkey
        res += std::to_string(sqlite3_column_int64(stmt, 2));
        res += ",";
        // quantity
        res += std::to_string(sqlite3_column_double(stmt, 3));
        res += ",";
        // extendedprice
        res += std::to_string(sqlite3_column_double(stmt, 4));
        res += ",";
        // discount
        res += std::to_string(sqlite3_column_double(stmt, 5));
        res += ",";
        // tax
        res += std::to_string(sqlite3_column_double(stmt, 6));
        res += ",";
        // returnflag
        res += '\'';
        const char *return_flag_ptr = (const char *)sqlite3_column_text(stmt, 7);
        std::string return_flag(return_flag_ptr, strlen(return_flag_ptr));
        res += return_flag;
        res += '\'';
        res += ",";
        // linestatus
        res += '\'';
        const char *line_status_ptr = (const char *)sqlite3_column_text(stmt, 8);
        std::string line_status(line_status_ptr, strlen(line_status_ptr));
        res += line_status;
        res += '\'';
        res += ",";
        // shipdate
        res += '\'';
        const char *ship_date_ptr = (const char *)sqlite3_column_text(stmt, 9);
        std::string ship_date(ship_date_ptr, strlen(ship_date_ptr));
        res += ship_date;
        res += '\'';
        
        res += ")";
    }

    sqlite3_finalize(stmt);
    return (res != "") ? ("INSERT INTO Lineitem VALUES " + std::move(res) + ";") : ""; 
}

void ecall_read_lineitem(char *buf, size_t length){
    (void)(length);
    auto res = read_lineitem();
    if ((res.size() + 1) > length) {
        ocall_println_string("ECALL READ LINEITEM - RESULT BIGGER THAN BUFFER");
        return;
    }
    memcpy(buf, res.c_str(), res.size() + 1);
}

void ecall_closedb(){
    sqlite3_close(db);
    ocall_println_string("Enclave: Closed database connection");
}

ATTESTATION_STATUS bifrost(sgx_enclave_id_t target, char** res, uint32_t target_fn_id) {
    dh_session_t* g_session;
    create_session(target, &g_session);

    ATTESTATION_STATUS ke_status = SUCCESS;
    uint32_t msg_type;
    char* marshalled_inp_buff;
    size_t marshalled_inp_buff_len;
    char* out_buff;
    size_t out_buff_len;
    size_t max_out_buff_size;
    char* secret_response;

    msg_type = MESSAGE_EXCHANGE;
    max_out_buff_size = 7000000; // 7MB
    
    ke_status = marshal_message_exchange_request(
        target_fn_id, msg_type,
        &marshalled_inp_buff, &marshalled_inp_buff_len
    );
    if(ke_status != SUCCESS)
    {   
        return ke_status;
    }

    //Core Reference Code function
    ke_status = send_request_receive_response(
        target, g_session,
        marshalled_inp_buff, marshalled_inp_buff_len,
        max_out_buff_size, &out_buff, &out_buff_len
    );
    if(ke_status != SUCCESS)
    {
        SAFE_FREE(marshalled_inp_buff);
        SAFE_FREE(out_buff);
        return ke_status;
    }

    //Un-marshal the secret response data
    size_t len;
    ke_status = unmarshal_message_exchange_response(out_buff, res, &len);

    if(ke_status != SUCCESS)
    {
        SAFE_FREE(marshalled_inp_buff);
        SAFE_FREE(out_buff);
        return ke_status;
    }

    SAFE_FREE(marshalled_inp_buff);
    SAFE_FREE(out_buff);

    std::string msg;
    msg += "Secure message exchange done (sent ";
    msg += std::to_string(marshalled_inp_buff_len);
    msg += " bytes, received ";
    msg += std::to_string(out_buff_len);
    msg += " bytes).";

    ocall_println_string(msg.c_str());
    close_session(target);

    return ke_status;
}

void ecall_q1(sgx_enclave_id_t *shared_eids, size_t length) {
    (void)(length);
    
    char* res;
    char *zErrMsg = 0;
    int rc;

    ocall_println_string("Fetching Lineitem");
    for (auto i = 0; i < length; i++) {
        auto x = shared_eids[i];
        bifrost(x, &res, 3); // Read lineitem
        if (strlen(res) == 0) continue;
        
        rc = sqlite3_exec(db, res, callback, 0, &zErrMsg);
        if (rc) {
            ocall_print_string("SQLite error: ");
            ocall_println_string(sqlite3_errmsg(db));
            return;
        }
    }

    ocall_println_string("Exectuing Q1");
    rc = sqlite3_exec(
        db,
        "SELECT "
            "L_RETURNFLAG,"
            "L_LINESTATUS,"
            "sum(L_QUANTITY) AS SUM_QTY,"
            "sum(L_EXTENDEDPRICE) AS SUM_BASE_PRICE,"
            "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT)) AS SUM_DISC_PRICE,"
            "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT) * (1+L_TAX)) AS SUM_CHARGE,"
            "avg(L_QUANTITY) AS AVG_QTY,"
            "avg(L_EXTENDEDPRICE) AS AVG_PRICE,"
            "avg(L_DISCOUNT) AS AVG_DISC,"
            "count(*) AS COUNT_ORDER "
        "FROM "
            "Lineitem "
        "WHERE "
            "L_SHIPDATE < '1998-08-31' "
        "GROUP BY "
            "L_RETURNFLAG,"
            "L_LINESTATUS "
        "ORDER BY "
            "L_RETURNFLAG,"
            "L_LINESTATUS;",
        callback, 0, &zErrMsg
    );
    if (rc) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return;
    }
}

void ecall_q6(sgx_enclave_id_t *shared_eids, size_t length) {
    (void)(length);
    
    char* res;
    char *zErrMsg = 0;
    int rc;

    ocall_println_string("Fetching Lineitem");
    for (auto i = 0; i < length; i++) {
        auto x = shared_eids[i];
        bifrost(x, &res, 3); // Read lineitem
        if (strlen(res) == 0) continue;
        
        rc = sqlite3_exec(db, res, callback, 0, &zErrMsg);
        if (rc) {
            ocall_print_string("SQLite error: ");
            ocall_println_string(sqlite3_errmsg(db));
            return;
        }
    }

    ocall_println_string("Exectuing Q6");
    rc = sqlite3_exec(
        db,
        "SELECT "
            "SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE "
        "FROM "
            "Lineitem "
        "WHERE "
            "L_SHIPDATE > '1993-12-31' "
            "AND L_SHIPDATE < '1995-01-01' "
            "AND L_DISCOUNT > 0.0499 "
            "AND L_DISCOUNT < 0.07001 "
            "AND L_QUANTITY < 24;",
        callback, 0, &zErrMsg
    );
    if (rc) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return;
    }
}

void ecall_q18(sgx_enclave_id_t *shared_eids, size_t length) {
    (void)(length);
    
    char* res;
    char *zErrMsg = 0;
    int rc;

    ocall_println_string("Fetching Customer, Lineitem and Orders");
    for (auto i = 0; i < length; i++) {
        auto x = shared_eids[i];

        // customer, orders, lineitem
        for (auto j = 1; j <=3; j++) {
            bifrost(x, &res, j); 
            if (strlen(res) != 0) {
                rc = sqlite3_exec(db, res, callback, 0, &zErrMsg);
                if (rc) {
                    ocall_print_string("SQLite error: ");
                    ocall_println_string(sqlite3_errmsg(db));
                    return;
                }
            }    
        }
    }

    ocall_println_string("Exectuing Q18");
    rc = sqlite3_exec(
        db,
        "SELECT "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE,"
            "SUM(L_QUANTITY) "
        "FROM "
            "Customer,"
            "Orders,"
            "Lineitem "
        "WHERE "
            "O_ORDERKEY IN ("
                "SELECT "
                    "L_ORDERKEY "
                "FROM "
                    "Lineitem "
                "GROUP BY "
                    "L_ORDERKEY HAVING "
                        "SUM(L_QUANTITY) > 1.0"
            ") "
            "AND C_CUSTKEY = O_CUSTKEY "
            "AND O_ORDERKEY = L_ORDERKEY "
        "GROUP BY "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE "
        "ORDER BY "
            "O_TOTALPRICE,"
            "O_ORDERDATE "
        "LIMIT 3;",
        callback, 0, &zErrMsg
    );
    if (rc) {
        ocall_print_string("SQLite error: ");
        ocall_println_string(sqlite3_errmsg(db));
        return;
    }
}
