#include <iostream>
#include <string>
#include <vector>
#include "sgx_urts.h"
#include "Enclave_u.h" // Headers for untrusted part (autogenerated by edger8r)
#include <unordered_set>
#include <fstream>
#include <ittnotify.h>

# define MAX_PATH FILENAME_MAX
# define ENCLAVE_FILENAME "enclave.signed.so"

__itt_domain* domain = __itt_domain_create("SGX.SQLite.Global");

// ocalls for printing string (C++ ocalls)
void ocall_print_error(const char *str){
    std::cerr << str << std::endl;
}

void ocall_print_string(const char *str){
    std::cout << str;
}

void ocall_println_string(const char *str){
    std::cout << str << std::endl;
}

std::string read_table(
    std::ifstream& lineitem,
    size_t num_rows,
    std::string tableName,
    std::unordered_set<int>& col_idx,
    std::unordered_set<int>& str_col
) {
    std::cout << "Reading " << tableName << std::endl;

    std::string delimiter = "|";
    std::string line;

    size_t row = 0;
    std::string accum;
    while (row++ < num_rows && std::getline(lineitem, line)) {
        std::string curr = "(";
        int col = 0;
        size_t pos = 0;
        std::string token;
        while ((pos = line.find(delimiter)) != std::string::npos) {
            token = line.substr(0, pos);
            if (col_idx.find(col) != col_idx.end()) {
                if (curr != "(") curr += ",";
                if (str_col.find(col) != str_col.end()) {
                    curr += ('\'' + token + '\'');
                } else {
                    curr += token;
                }
            }
            line.erase(0, pos + delimiter.length());
            col++;
        }
        if (accum != "") accum += ",";
        accum += (std::move(curr) + ")");
    }

    return "INSERT INTO " + tableName + " VALUES " + accum + ";";
}

void init_tables(sgx_enclave_id_t eid, std::string base) {
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    ret =  ecall_execute_sql(eid,
        "PRAGMA page_size = 65536"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "PRAGMA max_page_count = 19530"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "PRAGMA cache_size = 4000"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Lineitem ("
            "L_ORDERKEY		BIGINT NOT NULL,"
            "L_PARTKEY		BIGINT NOT NULL,"
            "L_SUPPKEY		BIGINT NOT NULL,"
            "L_QUANTITY		DECIMAL,"
            "L_EXTENDEDPRICE	DECIMAL,"
            "L_DISCOUNT		DECIMAL,"
            "L_TAX			DECIMAL,"
            "L_RETURNFLAG	CHAR(1),"
            "L_LINESTATUS	CHAR(1),"
            "L_SHIPDATE		DATE"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Orders ("
            "O_ORDERKEY		INT,"
            "O_CUSTKEY		BIGINT NOT NULL,"
            "O_TOTALPRICE	DECIMAL,"
            "O_ORDERDATE	DATE,"
            "O_SHIPPRIORITY	INTEGER"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Customer ("
            "C_CUSTKEY		INT,"
            "C_NAME			VARCHAR(25),"
            "C_NATIONKEY	BIGINT NOT NULL,"
            "C_ACCTBAL		DECIMAL,"
            "C_MKTSEGMENT	CHAR(10)"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    size_t dummy = 0;

    std::ifstream lineitem((base + "lineitem.tbl").c_str());
    std::unordered_set<int> lineitem_col_idx {
        0, 1, 2, 4, 5, 6, 7, 8, 9, 10
    };
    std::unordered_set<int> lineitem_str_col {
        8, 9, 10
    };
    ret =  ecall_execute_sql(eid,
        read_table(
            lineitem, dummy - 1, "Lineitem", lineitem_col_idx, lineitem_str_col
        ).c_str()
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    // std::ifstream orders((base + "orders.tbl").c_str());
    // std::unordered_set<int> orders_col_idx {
    //     0, 1, 3, 4, 7
    // };
    // std::unordered_set<int> orders_str_col {
    //     4
    // };
    // ret =  ecall_execute_sql(eid,
    //     read_table(
    //         orders, dummy - 1, "Orders", orders_col_idx, orders_str_col
    //     ).c_str()
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }

    // std::ifstream customer((base + "customer.tbl").c_str());
    // std::unordered_set<int> customer_col_idx {
    //     0, 1, 3, 5, 6
    // };
    // std::unordered_set<int> customer_str_col {
    //     1, 6
    // };
    // ret =  ecall_execute_sql(eid,
    //     read_table(
    //         customer, dummy - 1, "Customer", customer_col_idx, customer_str_col
    //     ).c_str()
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
}

void init_tables_multi(std::vector<sgx_enclave_id_t> eids) {
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    for (auto eid : eids) {
        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Lineitem ("
                "L_ORDERKEY		BIGINT NOT NULL,"
                "L_PARTKEY		BIGINT NOT NULL,"
                "L_SUPPKEY		BIGINT NOT NULL,"
                "L_QUANTITY		DECIMAL,"
                "L_EXTENDEDPRICE	DECIMAL,"
                "L_DISCOUNT		DECIMAL,"
                "L_TAX			DECIMAL,"
                "L_RETURNFLAG	CHAR(1),"
                "L_LINESTATUS	CHAR(1),"
                "L_SHIPDATE		DATE"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Customer ("
                "C_CUSTKEY		INT,"
                "C_NATIONKEY	BIGINT NOT NULL,"
                "C_ACCTBAL		DECIMAL,"
                "C_NAME			VARCHAR(25),"
                "C_MKTSEGMENT	CHAR(10)"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        
        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Orders ("
                "O_ORDERKEY		INT,"
                "O_CUSTKEY		BIGINT NOT NULL,"
                "O_TOTALPRICE	DECIMAL,"
                "O_ORDERDATE	DATE,"
                "O_SHIPPRIORITY	INTEGER"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }

    // auto eid_1 = eids[0];
    // auto eid_2 = eids[1];
    // auto eid_3 = eids[2];

    // ret =  ecall_execute_sql(eid_2,
    //     "INSERT INTO Lineitem VALUES"
    //         "(2, 3, 3, 'A', 'F', 65, 70, 8, 7712.48, 0.06, 0.02, '1996-02-28'),"
    //         "(3, 4, 4, 'A', 'F', 65, 70, 5, 25284.00, 0.06, 0.06, '1994-12-31');"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
    // ret =  ecall_execute_sql(eid_3,
    //     "INSERT INTO Lineitem VALUES"
    //         "(1, 1, 1, 'N', 'O', 78, 79, 17, 17954.55, 0.10, 0.02, '1992-03-13'),"
    //         "(1, 2, 2, 'N', 'O', 78, 79, 21, 34850.16, 0.05, 0.06, '1994-04-12');"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }

    // ret =  ecall_execute_sql(eid_1,
    //    "INSERT INTO Customer VALUES"
    //         "(1, 1, 7498.12, 'Customer#000000003', 'HOUSEHOLD');"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
    // ret =  ecall_execute_sql(eid_2,
    //    "INSERT INTO Customer VALUES"
    //         "(4, 15, 711.56, 'Customer#000000001', 'AUTOMOBILE'),"
    //         "(4, 4, 2866.83, 'Customer#000000004', 'BUILDING');"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
    // ret =  ecall_execute_sql(eid_3,
    //    "INSERT INTO Customer VALUES"
    //         "(7, 13, 121.65, 'Customer#000000002', 'MACHINERY');"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }

    // ret =  ecall_execute_sql(eid_1,
    //     "INSERT INTO Orders VALUES"
    //         "(1, 4, 178821.73, '1998-01-24', 1),"
    //         "(1, 7, 154260.84, '1992-05-01', 1);"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
    // ret =  ecall_execute_sql(eid_2,
    //     "INSERT INTO Orders VALUES"
    //         "(2, 1, 202660.52, '1992-12-21', 1);"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
    // ret =  ecall_execute_sql(eid_3,
    //     "INSERT INTO Orders VALUES"
    //         "(3, 4, 155680.60, '1994-06-18', 1);"
    // );
    // if (ret != SGX_SUCCESS) {
    //     std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //     return;
    // }
}

void q1(sgx_enclave_id_t eid, long size) {
    __itt_string_handle* handle = __itt_string_handle_create(
        ("Q1 [Single enclave] - " + std::to_string(size) + "MB").c_str()
    );
    for (int i = 0; i < 3; i++) {
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        sgx_status_t ret =  ecall_execute_sql(eid,
            "SELECT "
                "L_RETURNFLAG,"
                "L_LINESTATUS,"
                "sum(L_QUANTITY) AS SUM_QTY,"
                "sum(L_EXTENDEDPRICE) AS SUM_BASE_PRICE,"
                "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT)) AS SUM_DISC_PRICE,"
                "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT) * (1+L_TAX)) AS SUM_CHARGE,"
                "avg(L_QUANTITY) AS AVG_QTY,"
                "avg(L_EXTENDEDPRICE) AS AVG_PRICE,"
                "avg(L_DISCOUNT) AS AVG_DISC,"
                "count(*) AS COUNT_ORDER "
            "FROM "
                "Lineitem "
            "WHERE "
                "L_SHIPDATE < '1998-08-31' "
            "GROUP BY "
                "L_RETURNFLAG,"
                "L_LINESTATUS "
            "ORDER BY "
                "L_RETURNFLAG,"
                "L_LINESTATUS;"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
        __itt_task_end(domain);
    }
}

void q6(sgx_enclave_id_t eid) {
    sgx_status_t ret =  ecall_execute_sql(eid,
        "SELECT "
            "SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE "
        "FROM "
            "Lineitem "
        "WHERE "
            "L_SHIPDATE > '1993-12-31' "
            "AND L_SHIPDATE < '1995-01-01' "
            "AND L_DISCOUNT > 0.0499 "
            "AND L_DISCOUNT < 0.07001 "
            "AND L_QUANTITY < 24;"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }
}

void q18(sgx_enclave_id_t eid) {
    sgx_status_t ret =  ecall_execute_sql(eid,
        "SELECT "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE,"
            "SUM(L_QUANTITY) "
        "FROM "
            "Customer,"
            "Orders,"
            "Lineitem "
        "WHERE "
            "O_ORDERKEY IN ("
                "SELECT "
                    "L_ORDERKEY "
                "FROM "
                    "Lineitem "
                "GROUP BY "
                    "L_ORDERKEY HAVING "
                        "SUM(L_QUANTITY) > 1.0"
            ") "
            "AND C_CUSTKEY = O_CUSTKEY "
            "AND O_ORDERKEY = L_ORDERKEY "
        "GROUP BY "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE "
        "ORDER BY "
            "O_TOTALPRICE,"
            "O_ORDERDATE "
        "LIMIT 3;"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }
}

int main_single(void){
    const char* dbname = ":memory:";

    sgx_enclave_id_t eid = 0;
    char token_path[MAX_PATH] = {'\0'};
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;


    // Open SQLite database
    ret = ecall_opendb(eid, dbname);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_open()" << std::endl;
        return -1;
    }

    init_tables(eid, "/home/bhsz/fyp/MultiKernelBenchmarks/data/tpch_256MB/");
    q1(eid, 256);
    // q6(eid);
    // q18(eid);

    // Closing SQLite database inside enclave
    ret =  ecall_closedb(eid);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_closedb()" << std::endl;
        return -1;
    }

    // Destroy the enclave
    sgx_destroy_enclave(eid);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: destroying enclave" << std::endl;
        return -1;
    }

    std::cout << "Info: SQLite SGX enclave successfully returned." << std::endl;
    return 0;
}

int main_multi(void){
    const char* dbname = ":memory:";

    sgx_enclave_id_t eid_1 = 0;
    sgx_enclave_id_t eid_2 = 0;
    sgx_enclave_id_t eid_3 = 0;
    sgx_enclave_id_t main_eid = 0;
    char token_path[MAX_PATH] = {'\0'};
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_1, NULL);
    ecall_init(eid_1, eid_1);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_2, NULL);
    ecall_init(eid_2, eid_2);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_3, NULL);
    ecall_init(eid_3, eid_3);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &main_eid, NULL);
    ecall_init(main_eid, main_eid);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;

    std::vector<sgx_enclave_id_t> eids {eid_1, eid_2, eid_3, main_eid};

    // Open SQLite database
    for (auto eid : eids) {
        ret = ecall_opendb(eid, dbname);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_open()" << std::endl;
            return -1;
        }
    }

    init_tables_multi(eids);

    // std::vector<sgx_enclave_id_t> tmp {eid_1, eid_2, eid_3};
    // std::ifstream lineitem("/home/bhsz/fyp/MultiKernelBenchmarks/data/tpch_16MB/lineitem.tbl");
    // for (auto eid : tmp) {
    //     ret = ecall_execute_sql(eid, read_lineitem(lineitem, 32114).c_str());
    //     if (ret != SGX_SUCCESS) {
    //         std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
    //         return -1;
    //     }
    // }
    // ecall_q1(main_eid, tmp.data(), tmp.size());

    // Closing SQLite database inside enclave
    for (auto eid : eids) {
        ret =  ecall_closedb(eid);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_closedb()" << std::endl;
            return -1;
        }
    }

    // Destroy the enclave
    for (auto eid : eids) {
        sgx_destroy_enclave(eid);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: destroying enclave" << std::endl;
            return -1;
        }
    }

    std::cout << "Info: SQLite SGX enclave successfully returned." << std::endl;
    return 0;
}

int main(void) {
    return main_single();
    // return main_multi();
}