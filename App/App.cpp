#include <iostream>
#include <string>
#include <vector>
#include "sgx_urts.h"
#include "Enclave_u.h" // Headers for untrusted part (autogenerated by edger8r)
#include <unordered_set>
#include <fstream>
#include <ittnotify.h>
#include <stdexcept>
#include <cmath>

# define MAX_PATH FILENAME_MAX
# define ENCLAVE_FILENAME "enclave.signed.so"

__itt_domain* domain = __itt_domain_create("SGX.SQLite.Global");

std::unordered_set<int> lineitem_col_idx {
    0, 1, 2, 4, 5, 6, 7, 8, 9, 10
};
std::unordered_set<int> lineitem_str_col {
    8, 9, 10
};
std::unordered_set<int> orders_col_idx {
    0, 1, 3, 4, 7
};
std::unordered_set<int> orders_str_col {
    4
};
std::unordered_set<int> customer_col_idx {
    0, 1, 3, 5, 6
};
std::unordered_set<int> customer_str_col {
    1, 6
};


// ocalls for printing string (C++ ocalls)
void ocall_print_error(const char *str){
    std::cerr << str << std::endl;
}

void ocall_print_string(const char *str){
    std::cout << str;
}

void ocall_println_string(const char *str){
    std::cout << str << std::endl;
}

long count_lines(std::string path) {
    std::ifstream lineitem(path);
    size_t total = 0;

    std::string line;
    while (std::getline(lineitem, line)) {
        total++;
    }

    return total;
}

std::vector<long> uniform_partition(long total, int n) {
    std::vector<long> res;
    long one = (total / n);

    for (auto i = 0; i < n - 1; i++) {
        res.push_back(one);
        total -= one;
    }
    res.push_back(total);

    return res;
}

std::vector<long> zipfian_partition(long total, int n) {
    int num_parts = (std::pow(2, n) - 1);
    long one = (total / num_parts);

    int mult = 1;
    std::vector<long> res;

    for (auto i = 0; i < n - 1; i++) {
        long curr = one * mult;
        res.push_back(curr);
        mult *= 2;
        total -= curr;
    }
    res.push_back(total);
    
    return res;
}

std::string read_table(
    std::ifstream& file,
    size_t num_rows,
    std::string tableName,
    std::unordered_set<int>& col_idx,
    std::unordered_set<int>& str_col
) {
    std::cout << "Reading " << tableName << std::endl;

    std::string delimiter = "|";
    std::string line;

    size_t row = 0;
    std::string accum;
    while (row++ < num_rows && std::getline(file, line)) {
        std::string curr = "(";
        int col = 0;
        size_t pos = 0;
        std::string token;
        while ((pos = line.find(delimiter)) != std::string::npos) {
            token = line.substr(0, pos);
            if (col_idx.find(col) != col_idx.end()) {
                if (curr != "(") curr += ",";
                if (str_col.find(col) != str_col.end()) {
                    curr += ('\'' + token + '\'');
                } else {
                    curr += token;
                }
            }
            line.erase(0, pos + delimiter.length());
            col++;
        }
        if (accum != "") accum += ",";
        accum += (std::move(curr) + ")");
    }

    return "INSERT INTO " + tableName + " VALUES " + accum + ";";
}

void init_tables(sgx_enclave_id_t eid, std::string base) {
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    ret =  ecall_execute_sql(eid,
        "PRAGMA page_size = 65536"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "PRAGMA max_page_count = 19530"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "PRAGMA cache_size = 4000"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Lineitem ("
            "L_ORDERKEY		BIGINT NOT NULL,"
            "L_PARTKEY		BIGINT NOT NULL,"
            "L_SUPPKEY		BIGINT NOT NULL,"
            "L_QUANTITY		DECIMAL,"
            "L_EXTENDEDPRICE	DECIMAL,"
            "L_DISCOUNT		DECIMAL,"
            "L_TAX			DECIMAL,"
            "L_RETURNFLAG	CHAR(1),"
            "L_LINESTATUS	CHAR(1),"
            "L_SHIPDATE		DATE"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Orders ("
            "O_ORDERKEY		INT,"
            "O_CUSTKEY		BIGINT NOT NULL,"
            "O_TOTALPRICE	DECIMAL,"
            "O_ORDERDATE	DATE,"
            "O_SHIPPRIORITY	INTEGER"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Customer ("
            "C_CUSTKEY		INT,"
            "C_NAME			VARCHAR(25),"
            "C_NATIONKEY	BIGINT NOT NULL,"
            "C_ACCTBAL		DECIMAL,"
            "C_MKTSEGMENT	CHAR(10)"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    size_t dummy = 0;

    std::ifstream lineitem((base + "lineitem.tbl").c_str());
    ret =  ecall_execute_sql(eid,
        read_table(
            lineitem, dummy - 1, "Lineitem", lineitem_col_idx, lineitem_str_col
        ).c_str()
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    std::ifstream orders((base + "orders.tbl").c_str());
    ret =  ecall_execute_sql(eid,
        read_table(
            orders, dummy - 1, "Orders", orders_col_idx, orders_str_col
        ).c_str()
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }

    std::ifstream customer((base + "customer.tbl").c_str());
    ret =  ecall_execute_sql(eid,
        read_table(
            customer, dummy - 1, "Customer", customer_col_idx, customer_str_col
        ).c_str()
    );
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
        return;
    }
}

void init_tables_multi(
    std::vector<sgx_enclave_id_t> eids,
    std::string base,
    const std::vector<long>& lineitem_partitions,
    const std::vector<long>& orders_partitions,
    const std::vector<long>& customer_partitions
) {
    if (
        (eids.size() != lineitem_partitions.size()) || 
        (eids.size() != orders_partitions.size()) ||
        (eids.size() != customer_partitions.size())
    ) {
        throw std::logic_error("Enclave and partition size mismatch");
    }

    std::cout << "Lineitem - ";
    for (auto p : lineitem_partitions) {
        std::cout << p << " ";
    }
    std::cout << std::endl;

    std::cout << "Orders - ";
    for (auto p : orders_partitions) {
        std::cout << p << " ";
    }
    std::cout << std::endl;

    std::cout << "Customer - ";
    for (auto p : customer_partitions) {
        std::cout << p << " ";
    }
    std::cout << std::endl;

    std::cout << std::endl;

    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    for (auto eid : eids) {
        ret =  ecall_execute_sql(eid,
            "PRAGMA page_size = 65536"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "PRAGMA max_page_count = 19530"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "PRAGMA cache_size = 4000"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Lineitem ("
                "L_ORDERKEY		BIGINT NOT NULL,"
                "L_PARTKEY		BIGINT NOT NULL,"
                "L_SUPPKEY		BIGINT NOT NULL,"
                "L_QUANTITY		DECIMAL,"
                "L_EXTENDEDPRICE	DECIMAL,"
                "L_DISCOUNT		DECIMAL,"
                "L_TAX			DECIMAL,"
                "L_RETURNFLAG	CHAR(1),"
                "L_LINESTATUS	CHAR(1),"
                "L_SHIPDATE		DATE"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Customer ("
                "C_CUSTKEY		INT,"
                "C_NATIONKEY	BIGINT NOT NULL,"
                "C_ACCTBAL		DECIMAL,"
                "C_NAME			VARCHAR(25),"
                "C_MKTSEGMENT	CHAR(10)"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Orders ("
                "O_ORDERKEY		INT,"
                "O_CUSTKEY		BIGINT NOT NULL,"
                "O_TOTALPRICE	DECIMAL,"
                "O_ORDERDATE	DATE,"
                "O_SHIPPRIORITY	INTEGER"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }

    for (auto i = 0; i < eids.size(); i++) {
        std::ifstream lineitem((base + "lineitem.tbl").c_str());
        ret =  ecall_execute_sql(eids[i],
            read_table(
                lineitem, lineitem_partitions[i], "Lineitem", lineitem_col_idx, lineitem_str_col
            ).c_str()
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        std::ifstream orders((base + "orders.tbl").c_str());
        ret =  ecall_execute_sql(eids[i],
            read_table(
                orders, orders_partitions[i], "Orders", orders_col_idx, orders_str_col
            ).c_str()
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }

        std::ifstream customer((base + "customer.tbl").c_str());
        ret =  ecall_execute_sql(eids[i],
            read_table(
                customer, customer_partitions[i], "Customer", customer_col_idx, customer_str_col
            ).c_str()
        );
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }
}

void q1(sgx_enclave_id_t eid, long size) {
    __itt_string_handle* handle = __itt_string_handle_create(
        ("Q1 [Single enclave] - " + std::to_string(size) + "MB").c_str()
    );
    for (int i = 0; i < 3; i++) {
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        sgx_status_t ret =  ecall_execute_sql(eid,
            "SELECT "
                "L_RETURNFLAG,"
                "L_LINESTATUS,"
                "sum(L_QUANTITY) AS SUM_QTY,"
                "sum(L_EXTENDEDPRICE) AS SUM_BASE_PRICE,"
                "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT)) AS SUM_DISC_PRICE,"
                "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT) * (1+L_TAX)) AS SUM_CHARGE,"
                "avg(L_QUANTITY) AS AVG_QTY,"
                "avg(L_EXTENDEDPRICE) AS AVG_PRICE,"
                "avg(L_DISCOUNT) AS AVG_DISC,"
                "count(*) AS COUNT_ORDER "
            "FROM "
                "Lineitem "
            "WHERE "
                "L_SHIPDATE < '1998-08-31' "
            "GROUP BY "
                "L_RETURNFLAG,"
                "L_LINESTATUS "
            "ORDER BY "
                "L_RETURNFLAG,"
                "L_LINESTATUS;"
        );
        __itt_task_end(domain);
        __itt_pause();
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }
}

void q6(sgx_enclave_id_t eid, long size) {
    __itt_string_handle* handle = __itt_string_handle_create(
        ("Q6 [Single enclave] - " + std::to_string(size) + "MB").c_str()
    );
    for (int i = 0; i < 3; i++) {
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        sgx_status_t ret =  ecall_execute_sql(eid,
            "SELECT "
                "SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE "
            "FROM "
                "Lineitem "
            "WHERE "
                "L_SHIPDATE > '1993-12-31' "
                "AND L_SHIPDATE < '1995-01-01' "
                "AND L_DISCOUNT > 0.0499 "
                "AND L_DISCOUNT < 0.07001 "
                "AND L_QUANTITY < 24;"
        );
        __itt_task_end(domain);
        __itt_pause();
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }
}

void q18(sgx_enclave_id_t eid, long size) {
    __itt_string_handle* handle = __itt_string_handle_create(
        ("Q18 [Single enclave] - " + std::to_string(size) + "MB").c_str()
    );
    for (int i = 0; i < 3; i++) {
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        sgx_status_t ret =  ecall_execute_sql(eid,
            "SELECT "
                "C_NAME,"
                "C_CUSTKEY,"
                "O_ORDERKEY,"
                "O_ORDERDATE,"
                "O_TOTALPRICE,"
                "SUM(L_QUANTITY) "
            "FROM "
                "Customer,"
                "Orders,"
                "Lineitem "
            "WHERE "
                "O_ORDERKEY IN ("
                    "SELECT "
                        "L_ORDERKEY "
                    "FROM "
                        "Lineitem "
                    "GROUP BY "
                        "L_ORDERKEY HAVING "
                            "SUM(L_QUANTITY) > 1.0"
                ") "
                "AND C_CUSTKEY = O_CUSTKEY "
                "AND O_ORDERKEY = L_ORDERKEY "
            "GROUP BY "
                "C_NAME,"
                "C_CUSTKEY,"
                "O_ORDERKEY,"
                "O_ORDERDATE,"
                "O_TOTALPRICE "
            "ORDER BY "
                "O_TOTALPRICE,"
                "O_ORDERDATE "
            "LIMIT 3;"
        );
        __itt_task_end(domain);
        __itt_pause();
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_execute_sql()" << std::endl;
            return;
        }
    }
}

int main_single(void){
    const char* dbname = ":memory:";

    sgx_enclave_id_t eid = 0;
    
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: creating enclave" << std::endl;
        return -1;
    }
    std::cout << "Info: SQLite SGX enclave successfully created." << std::endl;


    // Open SQLite database
    ret = ecall_opendb(eid, dbname);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_open()" << std::endl;
        return -1;
    }

    // init_tables(eid, "/home/bhsz/fyp/MultiKernelBenchmarks/data/tpch_256MB/");
    // q1(eid, 256);
    // q6(eid);
    // q18(eid, 256);

    // Closing SQLite database inside enclave
    ret =  ecall_closedb(eid);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: Making an ecall_closedb()" << std::endl;
        return -1;
    }

    // Destroy the enclave
    sgx_destroy_enclave(eid);
    if (ret != SGX_SUCCESS) {
        std::cerr << "Error: destroying enclave" << std::endl;
        return -1;
    }

    std::cout << "Info: SQLite SGX enclave successfully returned." << std::endl;
    return 0;
}

int main_multi(int n_enclaves, std::string size, int q_to_run, bool use_zipf = false) {
    const char* dbname = ":memory:";

    sgx_enclave_id_t eids[n_enclaves];

    sgx_launch_token_t token = {0};
    int updated = 0;
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    // Initialize the enclaves
    for (auto i = 0; i < n_enclaves; i++) {
        ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eids[i], NULL);
        ecall_init(eids[i], eids[i]);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: creating enclave" << std::endl;
            return -1;
        }
    }       

    // Open SQLite database
    for (auto eid : eids) {
        ret = ecall_opendb(eid, dbname);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_open()" << std::endl;
            return -1;
        }
    }

    std::vector<sgx_enclave_id_t> tmp(eids, eids + n_enclaves);
    std::string base = "/home/bhsz/fyp/MultiKernelBenchmarks/data/tpch_" + size + "MB/";
    init_tables_multi(
        tmp,
        base,
        (use_zipf)
            ? zipfian_partition(count_lines(base + "lineitem.tbl"), n_enclaves)
            : uniform_partition(count_lines(base + "lineitem.tbl"), n_enclaves),
        (use_zipf)
            ? zipfian_partition(count_lines(base + "orders.tbl"), n_enclaves)
            : uniform_partition(count_lines(base + "orders.tbl"), n_enclaves),
        (use_zipf)
            ? zipfian_partition(count_lines(base + "customer.tbl"), n_enclaves)
            : uniform_partition(count_lines(base + "customer.tbl"), n_enclaves)
    );
    
    if (q_to_run == 1) {
         __itt_string_handle* handle = __itt_string_handle_create(
            (
                std::string("Q1")
                + ((use_zipf) ? " zipf " : " uniform ")
                + std::to_string(n_enclaves) + " enclaves "
                + size + "MB"
            ).c_str()
        );
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        ecall_q1(eids[0], &eids[1], n_enclaves - 1);
        __itt_task_end(domain);
        __itt_pause();
    } else if (q_to_run == 6) {
        __itt_string_handle* handle = __itt_string_handle_create(
            (
                std::string("Q6")
                + ((use_zipf) ? " zipf " : " uniform ")
                + std::to_string(n_enclaves) + " enclaves "
                + size + "MB"
            ).c_str()
        );
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        ecall_q6(eids[0], &eids[1], n_enclaves - 1);
        __itt_task_end(domain);
        __itt_pause();
    } else if (q_to_run == 18) {
        __itt_string_handle* handle = __itt_string_handle_create(
            (
                std::string("Q18")
                + ((use_zipf) ? " zipf " : " uniform ")
                + std::to_string(n_enclaves) + " enclaves "
                + size + "MB"
            ).c_str()
        );
        __itt_resume();
        __itt_task_begin(domain, __itt_null, __itt_null, handle);
        ecall_q6(eids[0], &eids[1], n_enclaves - 1);
        __itt_task_end(domain);
        __itt_pause();
    } else {
        throw std::invalid_argument("No such query supported");
    }

    // Closing SQLite database inside enclave
    for (auto eid : eids) {
        ret =  ecall_closedb(eid);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: Making an ecall_closedb()" << std::endl;
            return -1;
        }
    }

    // Destroy the enclave
    for (auto eid : eids) {
        sgx_destroy_enclave(eid);
        if (ret != SGX_SUCCESS) {
            std::cerr << "Error: destroying enclave" << std::endl;
            return -1;
        }
    }

    std::cout << "Info: SQLite SGX enclave successfully returned." << std::endl;
    return 0;
}

int main(int argc, char** argv) {
    __itt_pause();

    if (argc != 5) {
        std::cout << "n_enclaves size query_to_run use_zipf" << std::endl;
        return -1;
    }

    // return main_single();
    return main_multi(
        std::stoi(std::string(argv[1])),
        std::string(argv[2]),
        std::stoi(std::string(argv[3])),
        (std::string(argv[4]) == "1")
    );
}