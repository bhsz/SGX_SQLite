#include <iostream>
#include <string>
#include <vector>
#include "sgx_urts.h"
#include "Enclave_u.h" // Headers for untrusted part (autogenerated by edger8r)

using namespace std;

# define MAX_PATH FILENAME_MAX
# define ENCLAVE_FILENAME "enclave.signed.so"

// ocalls for printing string (C++ ocalls)
void ocall_print_error(const char *str){
    cerr << str << endl;
}

void ocall_print_string(const char *str){
    cout << str;
}

void ocall_println_string(const char *str){
    cout << str << endl;
}

void init_tables(sgx_enclave_id_t eid) {
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Lineitem ("
            "L_ORDERKEY		BIGINT NOT NULL,"
            "L_PARTKEY		BIGINT NOT NULL,"
            "L_SUPPKEY		BIGINT NOT NULL,"
            "L_RETURNFLAG	CHAR(1),"
            "L_LINESTATUS	CHAR(1),"
            "L_RETURNFLAG_INT	INT,"
            "L_LINESTATUS_INT	INT,"
            "L_QUANTITY		DECIMAL,"
            "L_EXTENDEDPRICE	DECIMAL,"
            "L_DISCOUNT		DECIMAL,"
            "L_TAX			DECIMAL,"
            "L_SHIPDATE		DATE"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "INSERT INTO Lineitem VALUES"
            "(1, 1, 1, 'N', 'O', 78, 79, 17, 17954.55, 0.10, 0.02, '1992-03-13'),"
            "(1, 2, 2, 'N', 'O', 78, 79, 21, 34850.16, 0.05, 0.06, '1994-04-12'),"
            "(2, 3, 3, 'A', 'F', 65, 70, 8, 7712.48, 0.06, 0.02, '1996-02-28'),"
            "(3, 4, 4, 'A', 'F', 65, 70, 5, 25284.00, 0.06, 0.06, '1994-12-31');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Customer ("
            "C_CUSTKEY		INT,"
            "C_NATIONKEY	BIGINT NOT NULL,"
            "C_ACCTBAL		DECIMAL,"
            "C_NAME			VARCHAR(25),"
            "C_MKTSEGMENT	CHAR(10)"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
       "INSERT INTO Customer VALUES"
            "(4, 15, 711.56, 'Customer#000000001', 'AUTOMOBILE'),"
            "(7, 13, 121.65, 'Customer#000000002', 'MACHINERY'),"
            "(1, 1, 7498.12, 'Customer#000000003', 'HOUSEHOLD'),"
            "(4, 4, 2866.83, 'Customer#000000004', 'BUILDING');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "CREATE TABLE Orders ("
            "O_ORDERKEY		INT,"
            "O_CUSTKEY		BIGINT NOT NULL,"
            "O_TOTALPRICE	DECIMAL,"
            "O_ORDERDATE	DATE,"
            "O_SHIPPRIORITY	INTEGER"
        ");"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid,
        "INSERT INTO Orders VALUES"
            "(1, 4, 178821.73, '1998-01-24', 1),"
            "(1, 7, 154260.84, '1992-05-01', 1),"
            "(2, 1, 202660.52, '1992-12-21', 1),"
            "(3, 4, 155680.60, '1994-06-18', 1);"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
}

void init_tables_multi(std::vector<sgx_enclave_id_t> eids) {
    sgx_status_t ret = SGX_ERROR_UNEXPECTED;

    for (auto eid : eids) {
        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Lineitem ("
                "L_ORDERKEY		BIGINT NOT NULL,"
                "L_PARTKEY		BIGINT NOT NULL,"
                "L_SUPPKEY		BIGINT NOT NULL,"
                "L_RETURNFLAG	CHAR(1),"
                "L_LINESTATUS	CHAR(1),"
                "L_RETURNFLAG_INT	INT,"
                "L_LINESTATUS_INT	INT,"
                "L_QUANTITY		DECIMAL,"
                "L_EXTENDEDPRICE	DECIMAL,"
                "L_DISCOUNT		DECIMAL,"
                "L_TAX			DECIMAL,"
                "L_SHIPDATE		DATE"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_execute_sql()" << endl;
            return;
        }

        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Customer ("
                "C_CUSTKEY		INT,"
                "C_NATIONKEY	BIGINT NOT NULL,"
                "C_ACCTBAL		DECIMAL,"
                "C_NAME			VARCHAR(25),"
                "C_MKTSEGMENT	CHAR(10)"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_execute_sql()" << endl;
            return;
        }

        
        ret =  ecall_execute_sql(eid,
            "CREATE TABLE Orders ("
                "O_ORDERKEY		INT,"
                "O_CUSTKEY		BIGINT NOT NULL,"
                "O_TOTALPRICE	DECIMAL,"
                "O_ORDERDATE	DATE,"
                "O_SHIPPRIORITY	INTEGER"
            ");"
        );
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_execute_sql()" << endl;
            return;
        }
    }

    auto eid_1 = eids[0];
    auto eid_2 = eids[1];
    auto eid_3 = eids[2];

    ret =  ecall_execute_sql(eid_2,
        "INSERT INTO Lineitem VALUES"
            "(2, 3, 3, 'A', 'F', 65, 70, 8, 7712.48, 0.06, 0.02, '1996-02-28'),"
            "(3, 4, 4, 'A', 'F', 65, 70, 5, 25284.00, 0.06, 0.06, '1994-12-31');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
    ret =  ecall_execute_sql(eid_3,
        "INSERT INTO Lineitem VALUES"
            "(1, 1, 1, 'N', 'O', 78, 79, 17, 17954.55, 0.10, 0.02, '1992-03-13'),"
            "(1, 2, 2, 'N', 'O', 78, 79, 21, 34850.16, 0.05, 0.06, '1994-04-12');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid_1,
       "INSERT INTO Customer VALUES"
            "(1, 1, 7498.12, 'Customer#000000003', 'HOUSEHOLD');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
    ret =  ecall_execute_sql(eid_2,
       "INSERT INTO Customer VALUES"
            "(4, 15, 711.56, 'Customer#000000001', 'AUTOMOBILE'),"
            "(4, 4, 2866.83, 'Customer#000000004', 'BUILDING');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
    ret =  ecall_execute_sql(eid_3,
       "INSERT INTO Customer VALUES"
            "(7, 13, 121.65, 'Customer#000000002', 'MACHINERY');"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }

    ret =  ecall_execute_sql(eid_1,
        "INSERT INTO Orders VALUES"
            "(1, 4, 178821.73, '1998-01-24', 1),"
            "(1, 7, 154260.84, '1992-05-01', 1);"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
    ret =  ecall_execute_sql(eid_2,
        "INSERT INTO Orders VALUES"
            "(2, 1, 202660.52, '1992-12-21', 1);"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
    ret =  ecall_execute_sql(eid_3,
        "INSERT INTO Orders VALUES"
            "(3, 4, 155680.60, '1994-06-18', 1);"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
}

void q1(sgx_enclave_id_t eid) {
    sgx_status_t ret =  ecall_execute_sql(eid,
        "SELECT "
            "L_RETURNFLAG,"
            "L_LINESTATUS,"
            "sum(L_QUANTITY) AS SUM_QTY,"
            "sum(L_EXTENDEDPRICE) AS SUM_BASE_PRICE,"
            "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT)) AS SUM_DISC_PRICE,"
            "sum(L_EXTENDEDPRICE * (1-L_DISCOUNT) * (1+L_TAX)) AS SUM_CHARGE,"
            "avg(L_QUANTITY) AS AVG_QTY,"
            "avg(L_EXTENDEDPRICE) AS AVG_PRICE,"
            "avg(L_DISCOUNT) AS AVG_DISC,"
            "count(*) AS COUNT_ORDER "
        "FROM "
            "Lineitem "
        "WHERE "
            "L_SHIPDATE < '1998-08-31' "
        "GROUP BY "
            "L_RETURNFLAG,"
            "L_LINESTATUS "
        "ORDER BY "
            "L_RETURNFLAG,"
            "L_LINESTATUS;"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
}

void q6(sgx_enclave_id_t eid) {
    sgx_status_t ret =  ecall_execute_sql(eid,
        "SELECT "
            "SUM(L_EXTENDEDPRICE * L_DISCOUNT) AS REVENUE "
        "FROM "
            "Lineitem "
        "WHERE "
            "L_SHIPDATE > '1993-12-31' "
            "AND L_SHIPDATE < '1995-01-01' "
            "AND L_DISCOUNT > 0.0499 "
            "AND L_DISCOUNT < 0.07001 "
            "AND L_QUANTITY < 24;"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
}

void q18(sgx_enclave_id_t eid) {
    sgx_status_t ret =  ecall_execute_sql(eid,
        "SELECT "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE,"
            "SUM(L_QUANTITY) "
        "FROM "
            "Customer,"
            "Orders,"
            "Lineitem "
        "WHERE "
            "O_ORDERKEY IN ("
                "SELECT "
                    "L_ORDERKEY "
                "FROM "
                    "Lineitem "
                "GROUP BY "
                    "L_ORDERKEY HAVING "
                        "SUM(L_QUANTITY) > 1.0"
            ") "
            "AND C_CUSTKEY = O_CUSTKEY "
            "AND O_ORDERKEY = L_ORDERKEY "
        "GROUP BY "
            "C_NAME,"
            "C_CUSTKEY,"
            "O_ORDERKEY,"
            "O_ORDERDATE,"
            "O_TOTALPRICE "
        "ORDER BY "
            "O_TOTALPRICE,"
            "O_ORDERDATE "
        "LIMIT 3;"
    );
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_execute_sql()" << endl;
        return;
    }
}

int main_single(void){
    const char* dbname = ":memory:";

    sgx_enclave_id_t eid = 0;
    char token_path[MAX_PATH] = {'\0'};
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return -1;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;


    // Open SQLite database
    ret = ecall_opendb(eid, dbname);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_open()" << endl;
        return -1;
    }

    // cout << "Enter SQL statement to execute or 'quit' to exit: " << endl;
    // string input;
    // cout << "> ";
    // while(getline(cin, input)) {
    //     if (input == "quit"){
    //         break;
    //     }
    //     const char* sql = input.c_str();
    //     ret =  ecall_execute_sql(eid, sql);
    //     if (ret != SGX_SUCCESS) {
    //         cerr << "Error: Making an ecall_execute_sql()" << endl;
    //         return -1;
    //     }
    //     cout << "> ";
    // }

    init_tables(eid);
    // q1(eid);
    // q6(eid);
    // q18(eid);

    // Closing SQLite database inside enclave
    ret =  ecall_closedb(eid);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: Making an ecall_closedb()" << endl;
        return -1;
    }

    // Destroy the enclave
    sgx_destroy_enclave(eid);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: destroying enclave" << endl;
        return -1;
    }

    cout << "Info: SQLite SGX enclave successfully returned." << endl;
    return 0;
}

int main_multi(void){
    const char* dbname = ":memory:";

    sgx_enclave_id_t eid_1 = 0;
    sgx_enclave_id_t eid_2 = 0;
    sgx_enclave_id_t eid_3 = 0;
    sgx_enclave_id_t main_eid = 0;
    char token_path[MAX_PATH] = {'\0'};
    sgx_launch_token_t token = {0};
    sgx_status_t ret = SGX_ERROR_UNEXPECTED; // status flag for enclave calls
    int updated = 0;

    // Initialize the enclave
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_1, NULL);
    ecall_init(eid_1, eid_1);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return -1;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_2, NULL);
    ecall_init(eid_2, eid_2);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return -1;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid_3, NULL);
    ecall_init(eid_3, eid_3);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return -1;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &main_eid, NULL);
    ecall_init(main_eid, main_eid);
    if (ret != SGX_SUCCESS) {
        cerr << "Error: creating enclave" << endl;
        return -1;
    }
    cout << "Info: SQLite SGX enclave successfully created." << endl;

    std::vector<sgx_enclave_id_t> eids {eid_1, eid_2, eid_3, main_eid};

    // Open SQLite database
    for (auto eid : eids) {
        ret = ecall_opendb(eid, dbname);
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_open()" << endl;
            return -1;
        }
    }

    init_tables_multi(eids);
    char buf[500] = {'\0'};

    std::vector<sgx_enclave_id_t> tmp {eid_1, eid_2, eid_3};
    // ecall_q1(main_eid, tmp.data(), tmp.size());
    // ecall_q6(main_eid, tmp.data(), tmp.size());
    ecall_q18(main_eid, tmp.data(), tmp.size());

    // Closing SQLite database inside enclave
    for (auto eid : eids) {
        ret =  ecall_closedb(eid);
        if (ret != SGX_SUCCESS) {
            cerr << "Error: Making an ecall_closedb()" << endl;
            return -1;
        }
    }

    // Destroy the enclave
    for (auto eid : eids) {
        sgx_destroy_enclave(eid);
        if (ret != SGX_SUCCESS) {
            cerr << "Error: destroying enclave" << endl;
            return -1;
        }
    }

    cout << "Info: SQLite SGX enclave successfully returned." << endl;
    return 0;
}

int main(void) {
    // return main_single();
    return main_multi();
}